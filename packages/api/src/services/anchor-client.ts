import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import { Connection, Keypair, PublicKey, SystemProgram } from '@solana/web3.js';
import { readFileSync } from 'fs';
import { join } from 'path';
import idl from '@haveibeendrained/shared/idl/drainer_registry.json';
import { PROGRAM_ID } from '@haveibeendrained/shared/constants';

export interface DrainerReport {
  drainerAddress: PublicKey;
  reportCount: number;
  firstSeen: number;
  lastSeen: number;
  totalSolReported: number;
  recentReporters: PublicKey[];
}

/**
 * Load wallet from environment variable or file path
 * Priority: ANCHOR_WALLET env var (as JSON) > file path > no wallet
 */
function loadWallet(walletPath?: string): Wallet | null {
  // First, try ANCHOR_WALLET environment variable (common production pattern)
  const envWallet = process.env.ANCHOR_WALLET;
  if (envWallet) {
    try {
      // Check if it's JSON content (starts with '[' or '{')
      if (envWallet.trim().startsWith('[') || envWallet.trim().startsWith('{')) {
        const secretKey = JSON.parse(envWallet);
        const walletKeypair = Keypair.fromSecretKey(Uint8Array.from(secretKey));
        return new Wallet(walletKeypair);
      }
      // If it's a path in env var, fall through to file reading below
    } catch (error) {
      console.warn('Failed to parse ANCHOR_WALLET from environment variable:', error);
    }
  }

  // Second, try provided walletPath (for backward compatibility)
  if (walletPath) {
    try {
      let secretKey: number[];
      
      // Check if walletPath is actually JSON content
      if (walletPath.trim().startsWith('[') || walletPath.trim().startsWith('{')) {
        // Direct JSON content
        secretKey = JSON.parse(walletPath);
      } else {
        // File path - read from filesystem
        const resolvedPath = walletPath.startsWith('/') 
          ? walletPath 
          : join(process.cwd(), walletPath);
        
        const walletData = readFileSync(resolvedPath, 'utf-8');
        secretKey = JSON.parse(walletData);
      }
      
      const walletKeypair = Keypair.fromSecretKey(Uint8Array.from(secretKey));
      return new Wallet(walletKeypair);
    } catch (error) {
      console.warn('Failed to load wallet from path:', walletPath, error);
    }
  }

  // If env var was a path, try reading it as a file
  if (envWallet && !envWallet.trim().startsWith('[') && !envWallet.trim().startsWith('{')) {
    try {
      const resolvedPath = envWallet.startsWith('/') 
        ? envWallet 
        : join(process.cwd(), envWallet);
      const walletData = readFileSync(resolvedPath, 'utf-8');
      const secretKey = JSON.parse(walletData);
      const walletKeypair = Keypair.fromSecretKey(Uint8Array.from(secretKey));
      return new Wallet(walletKeypair);
    } catch (error) {
      console.warn('Failed to load wallet from ANCHOR_WALLET file path:', error);
    }
  }

  return null;
}

export class AnchorClient {
  private program: Program;
  private connection: Connection;
  private wallet: Wallet | null = null;

  constructor(connection: Connection, walletPath?: string) {
    this.connection = connection;
    this.wallet = loadWallet(walletPath);

    // Create provider (always use provided connection, wallet is optional)
    // If wallet is provided, use it; otherwise create a dummy wallet for read-only operations
    const provider = this.wallet
      ? new AnchorProvider(connection, this.wallet, {})
      : new AnchorProvider(connection, new Wallet(Keypair.generate()), {});

    // Create Program with IDL (generated by Anchor 0.32.1 via dockerized build)
    // * Program constructor signature: (idl, provider, coder?, getCustomResolver?)
    // * Program ID comes from idl.address, not a separate parameter
    this.program = new Program(idl as any, provider);
  }

  /**
   * Get a drainer report from the on-chain registry
   * @param drainerAddress - The drainer address to query
   * @returns DrainerReport or null if not found
   */
  async getDrainerReport(drainerAddress: string | PublicKey): Promise<DrainerReport | null> {
    try {
      const pubkey = typeof drainerAddress === 'string' 
        ? new PublicKey(drainerAddress) 
        : drainerAddress;

      // Derive PDA
      const [pda] = PublicKey.findProgramAddressSync(
        [Buffer.from('drainer'), pubkey.toBuffer()],
        this.program.programId
      );

      // Fetch account using program account client
      const account = await this.program.account.drainerReport.fetch(pda);

      return {
        drainerAddress: account.drainerAddress,
        reportCount: account.reportCount.toNumber(),
        firstSeen: account.firstSeen.toNumber(),
        lastSeen: account.lastSeen.toNumber(),
        totalSolReported: account.totalSolReported.toNumber(),
        recentReporters: account.recentReporters,
      };
    } catch (error: any) {
      // Account doesn't exist or invalid data
      if (error.message?.includes('AccountNotFound') || 
          error.message?.includes('InvalidAccountData') ||
          error.message?.includes('decode')) {
        return null;
      }
      throw error;
    }
  }

  /**
   * Check if an address is a known drainer
   * @param address - Address to check
   * @returns true if address has reports, false otherwise
   */
  async isKnownDrainer(address: string | PublicKey): Promise<boolean> {
    const report = await this.getDrainerReport(address);
    return report !== null && report.reportCount > 0;
  }

  /**
   * Submit a drainer report to the on-chain registry
   * Note: This requires a wallet with SOL to pay the anti-spam fee
   * @param drainerAddress - The drainer address to report
   * @param amountStolen - Optional amount stolen in lamports
   * @param reporterWallet - Optional wallet to use for reporting (defaults to configured wallet)
   * @returns Transaction signature
   */
  async reportDrainer(
    drainerAddress: string | PublicKey,
    amountStolen?: number,
    reporterWallet?: Keypair
  ): Promise<string> {
    if (!this.wallet && !reporterWallet) {
      throw new Error('No wallet available for reporting. Provide wallet path or reporterWallet.');
    }

    const pubkey = typeof drainerAddress === 'string' 
      ? new PublicKey(drainerAddress) 
      : drainerAddress;

    // Derive PDA
    const [drainerReportPda] = PublicKey.findProgramAddressSync(
      [Buffer.from('drainer'), pubkey.toBuffer()],
      this.program.programId
    );

    // Get program authority (for receiving fees)
    // In production, this should be a configured authority address
    const programAuthority = this.wallet?.publicKey || reporterWallet!.publicKey;

    // Build transaction
    const tx = await this.program.methods
      .reportDrainer(pubkey, amountStolen ? new BN(amountStolen) : null)
      .accounts({
        drainerReport: drainerReportPda,
        reporter: this.wallet?.publicKey || reporterWallet!.publicKey,
        programAuthority,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    return tx;
  }

  /**
   * Update AI-generated metadata for a drainer report
   * @param drainerAddress - The drainer address
   * @param category - Attack category (0-4, 255 for Unknown)
   * @param methods - Attack method IDs (array of 0-9)
   * @param summary - AI-generated summary (max 500 chars)
   * @param domains - Key domains (max 5, 100 chars each)
   * @param confidence - AI confidence score (0-100)
   * @returns Transaction signature
   */
  async updateAiMetadata(
    drainerAddress: string | PublicKey,
    category: number,
    methods: number[],
    summary: string,
    domains: string[],
    confidence: number
  ): Promise<string> {
    if (!this.wallet) {
      throw new Error('Wallet required for updating AI metadata. Only program authority can update.');
    }

    const pubkey = typeof drainerAddress === 'string' 
      ? new PublicKey(drainerAddress) 
      : drainerAddress;

    // Derive PDA
    const [drainerReportPda] = PublicKey.findProgramAddressSync(
      [Buffer.from('drainer'), pubkey.toBuffer()],
      this.program.programId
    );

    // Convert methods to Vec<u8>
    const methodsVec = methods.slice(0, 10).map(m => m);

    // Truncate summary and domains to fit on-chain constraints
    const summaryTruncated = summary.slice(0, 500);
    const domainsTruncated = domains.slice(0, 5).map(d => d.slice(0, 100));

    // Build transaction
    const tx = await this.program.methods
      .updateAiMetadata(
        category,
        methodsVec,
        summaryTruncated,
        domainsTruncated,
        confidence
      )
      .accounts({
        drainerReport: drainerReportPda,
        programAuthority: this.wallet.publicKey,
      })
      .rpc();

    return tx;
  }

  /**
   * Get all drainer reports (requires indexing or RPC filtering)
   * Note: This is a placeholder - in production you'd use an indexer
   */
  async getAllDrainerReports(): Promise<DrainerReport[]> {
    // This would require program account enumeration or an indexer
    // For MVP, we'll return empty array and note this limitation
    console.warn('getAllDrainerReports not implemented - requires indexer');
    return [];
  }
}

