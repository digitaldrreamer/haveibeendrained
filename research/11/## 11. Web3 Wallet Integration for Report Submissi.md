<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# \#\# 11. Web3 Wallet Integration for Report Submission

### Research Questions

**Wallet Adapter:**

- What is the current version of Solana Wallet Adapter (as of December 2025)?
- What wallets does it support (Phantom, Solflare, Backpack, etc.)?
- How do you integrate Wallet Adapter with Svelte?
- Are there any Svelte-specific wallet libraries?

**Connection Flow:**

- How do you detect installed wallets?
- How do you handle the wallet connection request?
- What happens when a user rejects the connection?
- How do you persist wallet connection across page reloads?

**Transaction Signing:**

- How do you build a transaction server-side and send it to the wallet for signing?
- What is the difference between signing a transaction and signing a message?
- How do you handle partial signing (multiple signers)?
- What transaction simulation should be done before sending to wallet?

**Message Signing:**

- How do you request a wallet to sign an arbitrary message?
- What message format should be used for authentication?
- How do you verify the signature server-side?
- How do you prevent replay attacks with nonces?

**Mobile Support:**

- How does wallet integration work on mobile browsers?
- What is WalletConnect, and how does it work with Solana?
- What are deep linking strategies for mobile wallets?

**Error Handling:**

- What are common wallet errors (user rejection, insufficient balance, network mismatch)?
- How do you handle wallet disconnection mid-session?
- How do you handle wallet switching (user changes wallet)?


### Desired Outputs

- Wallet Adapter integration example for Svelte
- Transaction building and signing flow with code examples
- Message signing for authentication example
- Mobile wallet integration guide
- Error handling patterns for common wallet issues

---

Perfect! Now I have comprehensive information. Let me create a detailed guide with practical code examples.

***

# Web3 Wallet Integration for Solana Report Submission

## Research Summary: Current State (December 2025)

### Wallet Adapter Versions \& Support

**Current Status:**

- **@solana/wallet-adapter-base:** v0.9.27 (latest as of June 2025)
- **@solana/wallet-adapter-phantom:** v0.9.28
- **Svelte-specific adapter:** @svelte-on-solana/wallet-adapter-core + UI components available

**Supported Wallets:**

- Phantom (most popular, 145K+ weekly downloads)
- Solflare (robust Solana focus, 24-word seed)
- Backpack (modern xNFT support)
- WalletConnect (bridging to mobile and other chains)
- Slope, Sollet, Torus (legacy support)

***

## 1. Wallet Adapter Integration with Svelte

### Setup \& Installation

```bash
npm install \
  @solana/web3.js \
  @solana/wallet-adapter-base \
  @solana/wallet-adapter-wallets \
  @svelte-on-solana/wallet-adapter-core \
  @svelte-on-solana/wallet-adapter-ui
```


### Svelte Store Setup (`lib/stores/wallet.ts`)

```typescript
import { writable, derived } from 'svelte/store';
import type { Wallet } from '@solana/wallet-adapter-base';
import { 
  PhantomWalletAdapter, 
  SolflareWalletAdapter,
  BackpackWalletAdapter
} from '@solana/wallet-adapter-wallets';

// Initialize wallet adapters
const WALLETS: Wallet[] = [
  new PhantomWalletAdapter(),
  new SolflareWalletAdapter(),
  new BackpackWalletAdapter(),
];

// Create writable stores
export const connectedWallet = writable<Wallet | null>(null);
export const publicKey = writable<string | null>(null);
export const isConnecting = writable(false);
export const connectionError = writable<string | null>(null);

// Persist wallet selection across reloads
export const selectedWalletName = writable<string | null>(
  typeof window !== 'undefined' ? 
    localStorage.getItem('selectedWallet') : 
    null
);

// Subscribe to save wallet selection
selectedWalletName.subscribe(name => {
  if (typeof window !== 'undefined') {
    if (name) {
      localStorage.setItem('selectedWallet', name);
    } else {
      localStorage.removeItem('selectedWallet');
    }
  }
});

// Wallet connection state
export const isConnected = derived(publicKey, $publicKey => !!$publicKey);

export const availableWallets = writable(WALLETS);
```


### Connection Provider Component (`lib/components/WalletProvider.svelte`)

```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import type { Wallet } from '@solana/wallet-adapter-base';
  import { 
    connectedWallet, 
    publicKey, 
    isConnecting, 
    connectionError,
    selectedWalletName,
    availableWallets
  } from '$lib/stores/wallet';

  let detectedWallets: Wallet[] = [];

  onMount(async () => {
    // Detect installed wallets
    detectedWallets = $availableWallets.filter(wallet => {
      try {
        // Check if wallet is installed
        return wallet.readyState === 'Installed';
      } catch {
        return false;
      }
    });

    // Auto-connect if wallet was previously selected
    if ($selectedWalletName && detectedWallets.length > 0) {
      const previousWallet = detectedWallets.find(
        w => w.name === $selectedWalletName
      );
      
      if (previousWallet) {
        await connectWallet(previousWallet);
      }
    }
  });

  async function connectWallet(wallet: Wallet) {
    isConnecting.set(true);
    connectionError.set(null);

    try {
      // Connect wallet
      await wallet.connect();
      
      const pubKey = wallet.publicKey;
      if (!pubKey) throw new Error('No public key after connection');

      // Update stores
      connectedWallet.set(wallet);
      publicKey.set(pubKey.toString());
      selectedWalletName.set(wallet.name);

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Connection failed';
      connectionError.set(errorMessage);
      console.error('Wallet connection error:', error);
    } finally {
      isConnecting.set(false);
    }
  }

  async function disconnectWallet() {
    try {
      if ($connectedWallet) {
        await $connectedWallet.disconnect();
      }
      connectedWallet.set(null);
      publicKey.set(null);
      selectedWalletName.set(null);
      connectionError.set(null);
    } catch (error) {
      connectionError.set('Disconnection failed');
      console.error('Disconnect error:', error);
    }
  }

  // Setup wallet event listeners
  $: if ($connectedWallet) {
    const unsubscribeConnect = $connectedWallet.on('connect', () => {
      console.log('Wallet connected');
    });

    const unsubscribeDisconnect = $connectedWallet.on('disconnect', () => {
      disconnectWallet();
    });

    return () => {
      unsubscribeConnect();
      unsubscribeDisconnect();
    };
  }
</script>

<slot />
```


### Usage in Layout (`routes/+layout.svelte`)

```svelte
<script lang="ts">
  import WalletProvider from '$lib/components/WalletProvider.svelte';
  import { isConnected, publicKey, isConnecting, connectionError } from '$lib/stores/wallet';
</script>

<WalletProvider>
  <header>
    {#if $isConnected}
      <div class="wallet-info">
        Connected: {$publicKey?.slice(0, 8)}...
      </div>
    {:else if $isConnecting}
      <p>Connecting...</p>
    {:else if $connectionError}
      <p class="error">{$connectionError}</p>
    {/if}
  </header>

  <main>
    <slot />
  </main>
</WalletProvider>

<style>
  header {
    padding: 1rem;
    border-bottom: 1px solid #ddd;
  }
  
  .wallet-info {
    font-weight: bold;
    color: #2ecc71;
  }
  
  .error {
    color: #e74c3c;
  }
</style>
```


***

## 2. Transaction Building \& Signing Flow

### Server-Side Transaction Builder (`src/routes/api/transactions/build-drain-report.ts`)

```typescript
import { 
  Connection, 
  PublicKey, 
  Transaction,
  TransactionMessage,
  VersionedTransaction,
  SystemProgram,
  LAMPORTS_PER_SOL
} from '@solana/web3.js';
import { BorshCoder } from '@coral-xyz/anchor';
import { drainReportIDL } from '$lib/idl/drain-report';

const connection = new Connection(
  process.env.SOLANA_RPC_URL || 'https://api.devnet.solana.com',
  'confirmed'
);

// Your on-chain program ID for drain reports
const PROGRAM_ID = new PublicKey(process.env.DRAIN_REPORT_PROGRAM_ID!);

export async function POST({ request }) {
  try {
    const { userPublicKey, drainReport } = await request.json();
    const userPubKey = new PublicKey(userPublicKey);

    // 1. Get latest blockhash (important for expiration)
    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');

    // 2. Build instruction to submit drain report
    const instruction = await buildSubmitReportInstruction(
      userPubKey,
      drainReport
    );

    // 3. Create transaction message
    const message = new TransactionMessage({
      instructions: [instruction],
      payerKey: userPubKey,
      recentBlockhash: blockhash,
    }).compileToV0Message();

    const versionedTx = new VersionedTransaction(message);

    // 4. Simulate transaction BEFORE sending to wallet
    const simulation = await connection.simulateTransaction(versionedTx, {
      replaceRecentBlockhash: true,
      signers: [], // No signers yet, just checking structure
    });

    if (simulation.value.err) {
      return new Response(JSON.stringify({
        error: `Simulation failed: ${simulation.value.err}`,
        logs: simulation.value.logs,
      }), { status: 400 });
    }

    // 5. Serialize transaction to base64 for wallet signing
    const serialized = Buffer.from(
      versionedTx.serialize()
    ).toString('base64');

    return new Response(JSON.stringify({
      transaction: serialized,
      blockhash,
      lastValidBlockHeight,
      simulationSuccess: true,
      estimatedFees: {
        lamports: 5000, // Typical Solana transaction fee
        sol: 5000 / LAMPORTS_PER_SOL,
      }
    }));

  } catch (error) {
    console.error('Transaction building error:', error);
    return new Response(JSON.stringify({
      error: error instanceof Error ? error.message : 'Unknown error',
    }), { status: 500 });
  }
}

async function buildSubmitReportInstruction(
  userPubKey: PublicKey,
  drainReport: any
) {
  // This would depend on your Anchor program IDL
  // Example structure:
  const coder = new BorshCoder(drainReportIDL);
  
  // Build the instruction according to your program
  // This is a simplified example - adapt to your actual program
  
  return SystemProgram.transfer({
    fromPubkey: userPubKey,
    toPubkey: new PublicKey(process.env.TREASURY_WALLET!),
    lamports: 1000, // Small rent payment for storing report
  });
}
```


### Client-Side Signing (`routes/submit-report/+page.svelte`)

```svelte
<script lang="ts">
  import { 
    connectedWallet, 
    publicKey, 
    isConnecting 
  } from '$lib/stores/wallet';
  import { VersionedTransaction, Connection } from '@solana/web3.js';

  let isSubmitting = false;
  let submitError = '';
  let txSignature = '';

  async function submitDrainReport() {
    if (!$connectedWallet || !$publicKey) {
      submitError = 'Wallet not connected';
      return;
    }

    isSubmitting = true;
    submitError = '';
    txSignature = '';

    try {
      // 1. Request transaction from server
      const buildResponse = await fetch('/api/transactions/build-drain-report', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userPublicKey: $publicKey,
          drainReport: {
            drainAddress: 'address-from-form',
            walletAddress: $publicKey,
            drainAmount: 1000000, // in lamports
            drainType: 'token-drain',
          }
        }),
      });

      if (!buildResponse.ok) {
        const error = await buildResponse.json();
        throw new Error(error.error);
      }

      const { transaction: txBase64, lastValidBlockHeight } = await buildResponse.json();

      // 2. Deserialize transaction
      const txBuffer = Buffer.from(txBase64, 'base64');
      const versionedTx = VersionedTransaction.deserialize(txBuffer);

      console.log('Transaction to sign:', versionedTx);

      // 3. Request wallet to sign
      const signedTx = await $connectedWallet.signTransaction(versionedTx);

      console.log('Transaction signed, sending...');

      // 4. Send signed transaction to blockchain
      const connection = new Connection(
        'https://api.devnet.solana.com',
        'confirmed'
      );

      const signature = await connection.sendRawTransaction(
        signedTx.serialize(),
        {
          skipPreflight: false,
          preflightCommitment: 'confirmed',
          maxRetries: 3,
        }
      );

      console.log('Transaction sent:', signature);
      txSignature = signature;

      // 5. Wait for confirmation
      const confirmation = await connection.confirmTransaction(
        {
          signature,
          blockhash: versionedTx.message.recentBlockhash,
          lastValidBlockHeight,
        },
        'confirmed'
      );

      if (confirmation.value.err) {
        throw new Error(`Transaction failed: ${confirmation.value.err}`);
      }

      console.log('Report submitted successfully!');

    } catch (error) {
      submitError = error instanceof Error ? error.message : 'Submission failed';
      console.error('Submit error:', error);
    } finally {
      isSubmitting = false;
    }
  }
</script>

<div class="submit-container">
  <h2>Submit Drain Report</h2>

  {#if txSignature}
    <div class="success">
      ‚úì Report submitted successfully!
      <a href="https://solscan.io/tx/{txSignature}" target="_blank">
        View on Solscan
      </a>
    </div>
  {/if}

  {#if submitError}
    <div class="error">
      {submitError}
    </div>
  {/if}

  <button 
    on:click={submitDrainReport}
    disabled={!$publicKey || isSubmitting}
  >
    {isSubmitting ? 'Submitting...' : 'Submit Report'}
  </button>
</div>

<style>
  .submit-container {
    max-width: 500px;
    margin: 2rem auto;
    padding: 2rem;
    border: 1px solid #ddd;
    border-radius: 8px;
  }

  button {
    width: 100%;
    padding: 1rem;
    background: #2ecc71;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
  }

  button:disabled {
    background: #95a5a6;
    cursor: not-allowed;
  }

  .error {
    color: #e74c3c;
    padding: 1rem;
    background: #fadbd8;
    border-radius: 4px;
    margin-bottom: 1rem;
  }

  .success {
    color: #27ae60;
    padding: 1rem;
    background: #d5f4e6;
    border-radius: 4px;
    margin-bottom: 1rem;
  }

  a {
    color: inherit;
    text-decoration: underline;
    margin-left: 0.5rem;
  }
</style>
```


***

## 3. Message Signing for Authentication

### Message Signing Implementation

```typescript
// lib/services/auth.ts
import { PublicKey } from '@solana/web3.js';
import nacl from 'tweetnacl';
import { decodeUTF8, encodeUTF8 } from 'tweetnacl-util';

/**
 * Generate a nonce-based authentication message to prevent replay attacks
 */
export function generateAuthMessage(publicKey: string, nonce: string): string {
  const timestamp = Math.floor(Date.now() / 1000);
  return `Sign this message to authenticate with Have I Been Drained\n\nWallet: ${publicKey}\nTimestamp: ${timestamp}\nNonce: ${nonce}`;
}

/**
 * Create a unique nonce (typically from server)
 */
export function generateNonce(): string {
  return Math.random().toString(36).substring(2, 15) + 
         Math.random().toString(36).substring(2, 15);
}

/**
 * Verify signature server-side
 */
export function verifySignature(
  message: string,
  signature: Uint8Array,
  publicKey: string
): boolean {
  try {
    const publicKeyBytes = new PublicKey(publicKey).toBytes();
    const messageBytes = decodeUTF8(message);
    
    return nacl.sign.detached.verify(
      messageBytes,
      signature,
      publicKeyBytes
    );
  } catch (error) {
    console.error('Signature verification failed:', error);
    return false;
  }
}
```


### Client-Side Message Signing (`routes/login/+page.svelte`)

```svelte
<script lang="ts">
  import { connectedWallet, publicKey } from '$lib/stores/wallet';
  import { generateAuthMessage, generateNonce } from '$lib/services/auth';

  let isSigningMessage = false;
  let authError = '';
  let authSuccess = false;

  async function signAuthMessage() {
    if (!$connectedWallet || !$publicKey) {
      authError = 'Wallet not connected';
      return;
    }

    isSigningMessage = true;
    authError = '';

    try {
      // 1. Generate nonce from server (prevents replay attacks)
      const nonceResponse = await fetch('/api/auth/nonce', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ publicKey: $publicKey }),
      });

      const { nonce } = await nonceResponse.json();

      // 2. Create message with nonce
      const message = generateAuthMessage($publicKey, nonce);

      // 3. Request wallet to sign message
      const encodedMessage = new TextEncoder().encode(message);
      const signature = await $connectedWallet.signMessage(encodedMessage);

      console.log('Message signed, signature:', signature);

      // 4. Send signature to server for verification
      const verifyResponse = await fetch('/api/auth/verify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          publicKey: $publicKey,
          message,
          signature: Buffer.from(signature).toString('base64'),
          nonce,
        }),
      });

      if (!verifyResponse.ok) {
        throw new Error('Signature verification failed');
      }

      const { token } = await verifyResponse.json();

      // 5. Save auth token
      localStorage.setItem('authToken', token);
      authSuccess = true;

      setTimeout(() => {
        window.location.href = '/dashboard';
      }, 1000);

    } catch (error) {
      authError = error instanceof Error ? error.message : 'Signing failed';
      console.error('Message signing error:', error);
    } finally {
      isSigningMessage = false;
    }
  }
</script>

<div class="login-container">
  <h2>Sign In</h2>
  <p>Sign a message with your wallet to authenticate</p>

  {#if authSuccess}
    <div class="success">Authenticated! Redirecting...</div>
  {/if}

  {#if authError}
    <div class="error">{authError}</div>
  {/if}

  <button 
    on:click={signAuthMessage}
    disabled={!$publicKey || isSigningMessage}
  >
    {isSigningMessage ? 'Signing...' : 'Sign in with Wallet'}
  </button>
</div>

<style>
  .login-container {
    max-width: 400px;
    margin: 4rem auto;
    padding: 2rem;
    border: 1px solid #ddd;
    border-radius: 8px;
    text-align: center;
  }

  button {
    width: 100%;
    padding: 1rem;
    background: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    margin-top: 1rem;
  }

  button:disabled {
    background: #95a5a6;
    cursor: not-allowed;
  }

  .error, .success {
    padding: 1rem;
    border-radius: 4px;
    margin-bottom: 1rem;
  }

  .error {
    color: #e74c3c;
    background: #fadbd8;
  }

  .success {
    color: #27ae60;
    background: #d5f4e6;
  }
</style>
```


### Server-Side Verification (`src/routes/api/auth/verify.ts`)

```typescript
import { verifySignature } from '$lib/services/auth';
import { json } from '@sveltejs/kit';

export async function POST({ request }) {
  try {
    const { publicKey, message, signature, nonce } = await request.json();

    // 1. Verify nonce hasn't expired (check in Redis/cache)
    const isNonceValid = await validateNonce(publicKey, nonce);
    if (!isNonceValid) {
      return json({ error: 'Nonce expired or invalid' }, { status: 401 });
    }

    // 2. Decode signature from base64
    const signatureBytes = new Uint8Array(
      Buffer.from(signature, 'base64')
    );

    // 3. Verify signature
    const isValid = verifySignature(message, signatureBytes, publicKey);

    if (!isValid) {
      return json({ error: 'Invalid signature' }, { status: 401 });
    }

    // 4. Create session/JWT token
    const token = await createAuthToken(publicKey);

    // 5. Invalidate nonce (one-time use)
    await invalidateNonce(publicKey, nonce);

    return json({ token, publicKey });

  } catch (error) {
    console.error('Auth verification error:', error);
    return json({ error: 'Verification failed' }, { status: 500 });
  }
}

// Implement nonce storage with Redis or in-memory cache
async function validateNonce(publicKey: string, nonce: string): Promise<boolean> {
  // Check if nonce exists and hasn't expired (5 min TTL)
  // This prevents replay attacks
  return true; // Replace with actual implementation
}

async function invalidateNonce(publicKey: string, nonce: string): Promise<void> {
  // Remove nonce after use
}

async function createAuthToken(publicKey: string): Promise<string> {
  // Create JWT or session token
  return 'token';
}
```


***

## 4. Mobile Wallet Integration

### Mobile Connection Strategies

**Current Best Practices (December 2025):**

#### Approach 1: WalletConnect (Recommended for Mobile)

```typescript
// lib/stores/walletconnect.ts
import { WalletConnectWalletAdapter } from '@solana/wallet-adapter-walletconnect';

const walletConnectAdapter = new WalletConnectWalletAdapter({
  network: 'mainnet-beta',
  options: {
    projectId: process.env.WALLETCONNECT_PROJECT_ID!, // Get from WalletConnect Dashboard
    relayUrl: 'wss://relay.walletconnect.com',
    metadata: {
      name: 'Have I Been Drained',
      description: 'Solana Wallet Security Checker',
      url: 'https://haveibeendrained.org',
      icons: ['https://haveibeendrained.org/logo.png'],
    },
  },
});

export default walletConnectAdapter;
```

**Key Advantages:**

- ‚úÖ Works on both mobile browser and native apps
- ‚úÖ No private key exposure
- ‚úÖ Persistent session across browser refresh
- ‚úÖ Support for complex multi-step flows

**Limitations:**

- QR code scanning required for first connection
- Requires WalletConnect v2 infrastructure


#### Approach 2: Deep Linking (For Native Mobile Apps)

‚ö†Ô∏è **Status:** Viable for simple operations only, NOT recommended for complex signing flows.

**Why Deep Linking is Limited:**

- Excessive app switching (one round trip per signature)
- Context loss between switches
- Poor UX for multi-transaction flows
- Not suitable for MWA (Mobile Wallet Adapter)

**Deep Link Format:**

```
solana-dapp://request?action=sign_message&message=...&return_to=https://yourapp.com
```


### Mobile-Optimized Connection Flow

```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { connectedWallet, publicKey } from '$lib/stores/wallet';

  let isMobile = false;
  let isWalletConnectMode = false;

  onMount(() => {
    // Detect mobile
    isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );

    // Use WalletConnect on mobile for better UX
    if (isMobile) {
      isWalletConnectMode = true;
    }
  });

  async function handleMobileConnection() {
    if (isWalletConnectMode) {
      // Use WalletConnect flow
      // This handles QR code or deep link internally
      const uri = await getWalletConnectURI();
      
      if (isMobile) {
        // Mobile browser - try deep linking first
        const deepLinkSupported = await tryDeepLink(uri);
        if (!deepLinkSupported) {
          // Fallback to QR display for copying
          displayQRCode(uri);
        }
      } else {
        // Desktop - show QR code
        displayQRCode(uri);
      }
    }
  }

  async function getWalletConnectURI(): Promise<string> {
    // WalletConnect adapter automatically generates URI
    return ''; // Actual implementation depends on adapter
  }

  async function tryDeepLink(uri: string): Promise<boolean> {
    // Attempt to open wallet via deep link
    // Return true if successful
    return false;
  }

  function displayQRCode(uri: string) {
    // Show QR code modal for scanning
  }
</script>

{#if isMobile}
  <button on:click={handleMobileConnection}>
    Connect Mobile Wallet
  </button>
{/if}
```


***

## 5. Comprehensive Error Handling

### Error Type Classification

```typescript
// lib/services/wallet-errors.ts

export enum WalletErrorType {
  USER_REJECTION = 'USER_REJECTION',
  INSUFFICIENT_BALANCE = 'INSUFFICIENT_BALANCE',
  NETWORK_ERROR = 'NETWORK_ERROR',
  INVALID_NETWORK = 'INVALID_NETWORK',
  SIGNATURE_ERROR = 'SIGNATURE_ERROR',
  BLOCKHASH_EXPIRED = 'BLOCKHASH_EXPIRED',
  WALLET_NOT_FOUND = 'WALLET_NOT_FOUND',
  CONNECTION_FAILED = 'CONNECTION_FAILED',
  SIMULATION_FAILED = 'SIMULATION_FAILED',
  ALREADY_CONNECTED = 'ALREADY_CONNECTED',
}

export interface WalletError {
  type: WalletErrorType;
  message: string;
  originalError?: Error;
  retryable: boolean;
  userFriendlyMessage: string;
}

export function classifyWalletError(error: any): WalletError {
  const errorStr = error?.message?.toLowerCase() || '';

  // User rejected the request
  if (errorStr.includes('user rejected') || errorStr.includes('user declined')) {
    return {
      type: WalletErrorType.USER_REJECTION,
      message: error.message,
      retryable: true,
      userFriendlyMessage: 'You rejected the request. Please try again.',
    };
  }

  // Insufficient SOL for fees
  if (errorStr.includes('insufficient') && errorStr.includes('balance')) {
    return {
      type: WalletErrorType.INSUFFICIENT_BALANCE,
      message: error.message,
      retryable: false,
      userFriendlyMessage: 'Insufficient SOL for transaction fees. Please top up your wallet.',
    };
  }

  // Blockhash expired (need fresh one)
  if (errorStr.includes('blockhash not found') || errorStr.includes('nonce')) {
    return {
      type: WalletErrorType.BLOCKHASH_EXPIRED,
      message: error.message,
      retryable: true,
      userFriendlyMessage: 'Transaction expired. Please try again.',
    };
  }

  // Network mismatch
  if (errorStr.includes('network') || errorStr.includes('cluster')) {
    return {
      type: WalletErrorType.INVALID_NETWORK,
      message: error.message,
      retryable: false,
      userFriendlyMessage: 'Network mismatch. Ensure your wallet is on Solana mainnet.',
    };
  }

  // Wallet not installed
  if (errorStr.includes('adapter') || errorStr.includes('installed')) {
    return {
      type: WalletErrorType.WALLET_NOT_FOUND,
      message: error.message,
      retryable: false,
      userFriendlyMessage: 'Wallet extension not found. Please install it.',
    };
  }

  // Default generic error
  return {
    type: WalletErrorType.NETWORK_ERROR,
    message: error.message || 'Unknown error',
    retryable: true,
    userFriendlyMessage: 'An error occurred. Please try again later.',
  };
}
```


### Error Handling in Transaction Flow

```svelte
<script lang="ts">
  import { classifyWalletError, WalletErrorType } from '$lib/services/wallet-errors';
  
  async function submitDrainReport() {
    try {
      // ... transaction building and signing
      
    } catch (error) {
      const walletError = classifyWalletError(error);

      switch (walletError.type) {
        case WalletErrorType.USER_REJECTION:
          // Silent - user just cancelled
          console.log('User cancelled');
          break;

        case WalletErrorType.INSUFFICIENT_BALANCE:
          // Show clear action - direct to faucet or exchange
          showError(walletError.userFriendlyMessage);
          openFaucet();
          break;

        case WalletErrorType.BLOCKHASH_EXPIRED:
          // Auto-retry with fresh blockhash
          console.log('Retrying with fresh blockhash...');
          setTimeout(() => submitDrainReport(), 500);
          break;

        case WalletErrorType.SIGNATURE_ERROR:
          // Wallet state issue - suggest reconnecting
          showError('Please disconnect and reconnect your wallet');
          break;

        default:
          showError(walletError.userFriendlyMessage);
      }

      console.error('Full error details:', walletError);
    }
  }
</script>
```


### Wallet Disconnection \& Switching

```typescript
// lib/stores/wallet.ts (expanded)

import { writable } from 'svelte/store';

export const connectedWallet = writable<Wallet | null>(null);
export const walletSwitching = writable(false);

// Monitor disconnection events
export function setupWalletEventListeners(wallet: Wallet) {
  return wallet.on('disconnect', () => {
    console.log('Wallet disconnected');
    connectedWallet.set(null);
    publicKey.set(null);
  });
}

// Handle wallet switching
export async function switchWallet(newWallet: Wallet) {
  walletSwitching.set(true);

  try {
    // Disconnect current wallet if any
    const current = get(connectedWallet);
    if (current) {
      await current.disconnect();
    }

    // Connect new wallet
    await newWallet.connect();
    connectedWallet.set(newWallet);
    publicKey.set(newWallet.publicKey?.toString() || null);

  } finally {
    walletSwitching.set(false);
  }
}
```


***

## 6. Transaction Simulation Best Practices

### Pre-Submission Simulation

```typescript
// lib/services/transaction-simulator.ts

import { Connection, VersionedTransaction } from '@solana/web3.js';

export async function simulateTransaction(
  connection: Connection,
  transaction: VersionedTransaction,
  commitment: 'confirmed' | 'finalized' = 'confirmed'
) {
  try {
    const simulation = await connection.simulateTransaction(transaction, {
      replaceRecentBlockhash: true,
      signers: [], // Don't need actual signatures for simulation
      commitment,
    });

    return {
      success: !simulation.value.err,
      error: simulation.value.err,
      logs: simulation.value.logs || [],
      units: simulation.value.unitsConsumed,
    };
  } catch (error) {
    console.error('Simulation error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Simulation failed',
      logs: [],
      units: undefined,
    };
  }
}

export function analyzeSimulationLogs(logs: string[]): {
  success: boolean;
  issues: string[];
  suggestions: string[];
} {
  const issues: string[] = [];
  const suggestions: string[] = [];

  logs.forEach(log => {
    if (log.includes('Program failed')) {
      issues.push('Program execution failed');
      suggestions.push('Check program authority and account permissions');
    }

    if (log.includes('insufficient lamports')) {
      issues.push('Insufficient SOL for rent');
      suggestions.push('Ensure account has minimum SOL balance');
    }

    if (log.includes('Signature verification')) {
      issues.push('Signature verification failed');
      suggestions.push('Check that all required accounts are signed');
    }
  });

  return {
    success: issues.length === 0,
    issues,
    suggestions,
  };
}
```


***

## 7. Cost Considerations

### Transaction Fee Structure (December 2025)

| Item | Cost | Notes |
| :-- | :-- | :-- |
| **Base Transaction Fee** | ~5,000 lamports (0.000005 SOL) | Covers basic transaction |
| **Compute Units** | 200-2000 CUs typical | Additional cost for complex operations |
| **Account Creation** | 890,880 lamports (0.00089088 SOL) | One-time rent exemption for new accounts |
| **RPC Requests** | Free | For public endpoints; paid Helius recommended for production |

### Cost-Saving Strategies

1. **Free RPC Options:**
    - Solana public RPC (rate-limited)
    - QuickNode free tier (rate-limited)
    - Helius free tier (generous - recommended for hackathon)
2. **Production RPC (If needed):**
    - **Helius:** \$0-49/month for generous free tier
    - **QuickNode:** \$4.99+/month
    - **Alchemy:** Free tier + paid plans
3. **Fee Optimization:**
    - Use priority fees only when network congestion is high
    - Batch multiple operations into single transaction
    - Use versioned transactions for lower overhead

***

## Summary \& Best Practices

### ‚úÖ Recommended Implementation Stack

- **Wallet Adapter:** @solana/wallet-adapter v0.9.27+
- **Svelte Integration:** @svelte-on-solana/wallet-adapter-core
- **Mobile:** WalletConnect v2 (not deep links)
- **RPC:** Helius (free tier for hackathon)
- **Message Signing:** nacl.js for Ed25519 verification
- **Storage:** localStorage for wallet persistence (NOT browser storage for sensitive data)


### ‚ö†Ô∏è Common Pitfalls to Avoid

1. **‚ùå Using localStorage for session tokens** ‚Üí Use secure httpOnly cookies instead
2. **‚ùå Not simulating transactions** ‚Üí Always simulate before asking user to sign
3. **‚ùå Reusing old blockhashes** ‚Üí Fresh blockhash required (expires after 150 blocks / ~60-90 seconds)
4. **‚ùå Deep linking on mobile** ‚Üí Use WalletConnect instead for smooth UX
5. **‚ùå Ignoring nonce in message signing** ‚Üí Critical for preventing replay attacks
6. **‚ùå Not handling wallet disconnection** ‚Üí Users can disconnect mid-flow

### üéØ For Your "Have I Been Drained" Project

**Recommended Flow:**

1. User connects wallet (Phantom/Solflare primary)
2. Sign auth message with nonce for login
3. Build drain report transaction server-side
4. Simulate transaction to verify it works
5. Request wallet to sign
6. Submit signed transaction
7. Wait for confirmation with timeout handling

This integrates security (nonce-based auth), UX (simulation feedback), and reliability (proper error handling across all phases).
<span style="display:none">[^1][^10][^11][^12][^13][^14][^15][^16][^17][^18][^19][^2][^20][^21][^22][^23][^24][^25][^26][^27][^28][^29][^3][^30][^4][^5][^6][^7][^8][^9]</span>

<div align="center">‚ÅÇ</div>

[^1]: https://www.npmjs.com/package/@solana/wallet-adapter-walletconnect

[^2]: https://svelter.in/library/wallet-adapter_svelte-on-solana

[^3]: https://coinpaper.com/11948/best-solana-wallets-2025-5-trusted-options-for-sol-holders

[^4]: https://www.npmjs.com/package/@solana/wallet-adapter-base?activeTab=dependents

[^5]: https://www.npmjs.com/package/@aztemi%2Fsvelte-on-solana-wallet-adapter-ui

[^6]: https://www.alchemy.com/overviews/solana-wallets

[^7]: https://solana.com/developers/cookbook/wallets/connect-wallet-react

[^8]: https://www.npmjs.com/package/@svelte-on-solana/wallet-adapter-core?activeTab=readme

[^9]: https://www.rocketx.exchange/blog/best-solana-wallets-guide/

[^10]: https://www.npmjs.com/package/@solana/wallet-adapter-phantom

[^11]: https://michaelhly.github.io/solana-py/cookbook/wallet-management/sign-verify-message/

[^12]: https://ramboskitchen.ca/wallet-connect-mobile-nft-collections-and-backup-recovery-navigating-solana-s-mobile-wallet-landscape/

[^13]: https://www.youtube.com/watch?v=uwCYY_pyRRY

[^14]: https://solana.com/developers/cookbook/wallets/sign-message

[^15]: https://docs.solanamobile.com/blog/ios-wallet-signing

[^16]: https://stackoverflow.com/questions/78353570/insufficient-funds-error-during-solana-transaction-via-jupiter-api-despite-adequ

[^17]: https://rareskills.io/post/solana-signature-verification

[^18]: https://docs.walletconnect.network/wallet-sdk/android/mobile-linking

[^19]: https://trustwallet.com/blog/guides/how-to-fund-your-solana-account-and-avoid-transaction-failures

[^20]: https://www.youtube.com/watch?v=QHkOQeSr4MM

[^21]: https://www.quicknode.com/guides/solana-development/transactions/how-to-send-offline-tx

[^22]: https://solana.com/developers/guides/advanced/confirmation

[^23]: https://v2.franknoirot.co/posts/svelte-kit-stores-localstorage/

[^24]: https://docs.shyft.to/tutorials/how-to-sign-transactions-on-solana

[^25]: https://stackoverflow.com/questions/70717996/blockhash-not-found-when-sending-transaction

[^26]: https://www.youtube.com/watch?v=1z77d6R4Ro4

[^27]: https://nick.af/articles/gill-solana-javascript-get-started

[^28]: https://www.quicknode.com/guides/solana-development/transactions/how-to-optimize-solana-transactions

[^29]: https://stackoverflow.com/questions/70217556/how-to-write-persist-in-svelte

[^30]: https://solana.com/developers/cookbook/transactions/offline-transactions

